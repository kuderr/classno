import typing as t

from classno import _casting
from classno import _delattrs
from classno import _dunders
from classno import _getattrs
from classno import _validation
from classno import constants as c


def set_keys(cls: t.Type, keys_attr: str) -> None:
    """
    Set default keys for comparison/hashing if not explicitly defined by user.

    If the user hasn't specified custom keys (e.g., __eq_keys__, __hash_keys__),
    this function sets them to include all fields by default.
    Empty tuples ARE allowed - they indicate no fields should be used for comparison.

    Inheritance behavior:
    - If keys are explicitly defined in this class, use them
    - If a parent class has USER-DEFINED keys, inherit them
    - Otherwise, set defaults to all fields of this class

    Auto-generated keys are marked with a {keys_attr}_autogenerated attribute.
    """
    # Check if explicitly defined in this class
    if keys_attr in cls.__dict__:
        return

    # Check if any parent (excluding Classno base) has USER-DEFINED keys
    for base in cls.__mro__[1:]:
        # Skip the Classno base class
        if base.__name__ == "Classno":
            continue
        # Check if parent explicitly defined keys
        if keys_attr in base.__dict__:
            # Check if it was auto-generated
            autogen_marker = f"{keys_attr}_autogenerated"
            if not getattr(base, autogen_marker, False):
                # User-defined keys, inherit them (don't override)
                return
            # Parent has auto-generated keys, child should get its own defaults

    # Not explicitly defined with user-defined keys anywhere, set defaults to all fields
    setattr(cls, keys_attr, tuple(cls.__fields__))
    # Mark as auto-generated so child classes know they can override
    setattr(cls, f"{keys_attr}_autogenerated", True)


def _is_user_defined(cls: t.Type, method_name: str) -> bool:
    """
    Check if a method was defined by the user in the class (not inherited).

    Returns True if the method exists in the class's __dict__, meaning it was
    explicitly defined by the user and should not be overridden.
    """
    return method_name in cls.__dict__


def repr_handler(cls: t.Type) -> None:
    if not _is_user_defined(cls, "__repr__"):
        cls.__repr__ = _dunders.__repr__


def eq_handler(cls: t.Type) -> None:
    if not _is_user_defined(cls, "__eq__"):
        cls.__eq__ = _dunders.__eq__
    cls._eq_value = _dunders._eq_value
    cls._cmp_factory = _dunders._cmp_factory
    set_keys(cls, c._CLASSNO_EQ_KEYS_ATTR)


def hash_handler(cls: t.Type) -> None:
    if not _is_user_defined(cls, "__hash__"):
        cls.__hash__ = _dunders.__hash__
    cls._hash_value = _dunders._hash_value
    set_keys(cls, c._CLASSNO_HASH_KEYS_ATTR)


def order_handler(cls: t.Type) -> None:
    # Only override comparison methods if user hasn't defined them
    if not _is_user_defined(cls, "__lt__"):
        cls.__lt__ = _dunders.__lt__
    if not _is_user_defined(cls, "__le__"):
        cls.__le__ = _dunders.__le__
    if not _is_user_defined(cls, "__gt__"):
        cls.__gt__ = _dunders.__gt__
    if not _is_user_defined(cls, "__ge__"):
        cls.__ge__ = _dunders.__ge__
    cls._order_value = _dunders._order_value
    cls._cmp_factory = _dunders._cmp_factory
    set_keys(cls, c._CLASSNO_ORDER_KEYS_ATTR)


def frozen_handler(cls: t.Type) -> None:
    if not _is_user_defined(cls, "__delattr__"):
        cls.__delattr__ = _delattrs.frozen_delattr


def private_handler(cls: t.Type) -> None:
    if not _is_user_defined(cls, "__getattr__"):
        cls.__getattr__ = _getattrs.privates_getattr


# Feature handlers for class-level customization
# These handlers check for user-defined methods before overriding them,
# allowing users to provide custom implementations while still benefiting
# from Classno features.
_CLASS_HANDLERS_MAP: dict[c.Features, t.Callable[[t.Type], None]] = {
    c.Features.REPR: repr_handler,
    c.Features.EQ: eq_handler,
    c.Features.HASH: hash_handler,
    c.Features.ORDER: order_handler,
    c.Features.FROZEN: frozen_handler,
    c.Features.PRIVATE: private_handler,
}


def validation_obj_handler(obj: object) -> None:
    _validation.validate_fields(obj)


def lossy_autocast_obj_handler(obj: object) -> None:
    _casting.cast_fields(obj)


# Object-level feature handlers
# ORDER IS CRITICAL: LOSSY_AUTOCAST must run before VALIDATION
# Rationale: When both features are enabled, values should first be automatically
# cast to their target types (LOSSY_AUTOCAST), then validated (VALIDATION).
# This ensures validation operates on properly typed values.
# Example: field: int with value="123" -> cast to 123 -> validate as int
_OBJECT_HANDLERS_MAP: dict[c.Features, t.Callable[[object], None]] = {
    c.Features.LOSSY_AUTOCAST: lossy_autocast_obj_handler,  # Step 1: Cast values
    c.Features.VALIDATION: validation_obj_handler,  # Step 2: Validate types
}
